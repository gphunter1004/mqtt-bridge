// internal/workflow/executor.go
package workflow

import (
	"encoding/json"
	"fmt"
	"mqtt-bridge/internal/config"
	"mqtt-bridge/internal/models"
	"mqtt-bridge/internal/repository"
	"mqtt-bridge/internal/utils"
	"time"

	mqtt "github.com/eclipse/paho.mqtt.golang"
	"github.com/go-redis/redis/v8"
	"gorm.io/gorm"
)

// CommandResultSender Î™ÖÎ†π Í≤∞Í≥º Ï†ÑÏÜ° Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
type CommandResultSender interface {
	SendResponseToPLC(command, status, errMsg string)
}

// Executor ÏõåÌÅ¨ÌîåÎ°úÏö∞ Ïã§Ìñâ ÏóîÏßÑ
type Executor struct {
	db                  *gorm.DB
	redisClient         *redis.Client
	mqttClient          mqtt.Client
	config              *config.Config
	orderBuilder        *OrderBuilder
	stepManager         *StepManager
	commandResultSender CommandResultSender
}

// NewExecutor ÏÉà ÏõåÌÅ¨ÌîåÎ°úÏö∞ Ïã§ÌñâÍ∏∞ ÏÉùÏÑ±
func NewExecutor(db *gorm.DB, redisClient *redis.Client, mqttClient mqtt.Client, cfg *config.Config,
	commandResultSender CommandResultSender) *Executor {

	utils.Logger.Infof("üèóÔ∏è CREATING Workflow Executor")

	orderBuilder := NewOrderBuilder(cfg)
	messageSender := &MQTTMessageSender{
		mqttClient: mqttClient,
		config:     cfg,
	}
	stepManager := NewStepManager(db, redisClient, orderBuilder, messageSender)

	executor := &Executor{
		db:                  db,
		redisClient:         redisClient,
		mqttClient:          mqttClient,
		config:              cfg,
		orderBuilder:        orderBuilder,
		stepManager:         stepManager,
		commandResultSender: commandResultSender,
	}

	utils.Logger.Infof("‚úÖ Workflow Executor CREATED")
	return executor
}

// ExecuteCommandOrder PLC Î™ÖÎ†πÏóê ÎåÄÌïú ÏõåÌÅ¨ÌîåÎ°úÏö∞ Ïã§Ìñâ ÏãúÏûë
func (e *Executor) ExecuteCommandOrder(command *models.Command) error {
	if command.CommandDefinition.CommandType == "" {
		e.db.Preload("CommandDefinition").First(&command, command.ID)
	}
	utils.Logger.Infof("Starting workflow for command: %s (ID: %d)", command.CommandDefinition.CommandType, command.ID)

	commandExecution := &models.CommandExecution{
		CommandID:         command.ID,
		Status:            models.CommandExecutionStatusRunning,
		CurrentOrderIndex: 1,
		StartedAt:         time.Now(),
	}
	if err := e.db.Create(commandExecution).Error; err != nil {
		return fmt.Errorf("failed to create command execution: %v", err)
	}

	return e.executeNextOrder(commandExecution)
}

// SendDirectActionOrder ÏßÅÏ†ë Ïï°ÏÖò Ïò§Îçî Ï†ÑÏÜ°
func (e *Executor) SendDirectActionOrder(baseCommand string, commandType rune, armParam string) (string, error) {
	directOrder, orderID, err := e.orderBuilder.BuildDirectActionOrder(baseCommand, commandType, armParam)
	if err != nil {
		return "", err
	}

	if err := e.sendOrder(directOrder); err != nil {
		return "", err
	}

	return orderID, nil
}

// HandleOrderStateUpdate Î°úÎ¥á ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ï≤òÎ¶¨
func (e *Executor) HandleOrderStateUpdate(stateMsg *models.RobotStateMessage) {
	// Îã®Í≥Ñ ÏôÑÎ£å ÌôïÏù∏ Î∞è Ï≤òÎ¶¨
	if e.stepManager.HandleStepCompletion(stateMsg) {
		// Îã®Í≥ÑÍ∞Ä ÏôÑÎ£åÎêòÏóàÏúºÎ©¥ Ï∂îÍ∞Ä Ï≤òÎ¶¨ ÏóÜÏùå (StepManagerÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®)
		return
	}
}

// CancelAllRunningOrders Î™®Îì† Ïã§Ìñâ Ï§ëÏù∏ Ïò§Îçî Ï∑®ÏÜå
func (e *Executor) CancelAllRunningOrders() error {
	var commandExecutions []models.CommandExecution
	e.db.Where("status = ?", models.CommandExecutionStatusRunning).Find(&commandExecutions)

	for _, cmdExec := range commandExecutions {
		now := time.Now()
		repository.UpdateCommandExecutionStatus(e.db, &cmdExec, models.CommandExecutionStatusCancelled, &now)

		var orderExecutions []models.OrderExecution
		e.db.Where("command_execution_id = ? AND status IN ?",
			cmdExec.ID, []string{models.OrderExecutionStatusRunning, models.OrderExecutionStatusPending}).
			Find(&orderExecutions)

		for _, orderExec := range orderExecutions {
			nowOrderExec := time.Now()
			repository.UpdateOrderExecutionStatus(e.db, &orderExec, models.OrderExecutionStatusFailed, &nowOrderExec)

			// Ïã§Ìñâ Ï§ëÏù∏ Îã®Í≥ÑÎì§ Ï∑®ÏÜå
			e.stepManager.CancelRunningSteps(orderExec.ID, "Cancelled by order cancel command")
		}
	}

	// Î°úÎ¥áÏóê Ï∑®ÏÜå Î©îÏãúÏßÄ Ï†ÑÏÜ°
	return e.SendCancelOrder()
}

// SendCancelOrder Î°úÎ¥áÏóê cancelOrder ÏöîÏ≤≠ Ï†ÑÏÜ°
func (e *Executor) SendCancelOrder() error {
	cancelMessage, err := e.orderBuilder.BuildCancelOrderMessage()
	if err != nil {
		return fmt.Errorf("failed to build cancel order message: %v", err)
	}

	reqData, err := json.Marshal(cancelMessage)
	if err != nil {
		return fmt.Errorf("failed to marshal cancelOrder request: %v", err)
	}

	topic := fmt.Sprintf("meili/v2/%s/%s/instantActions", e.config.RobotManufacturer, e.config.RobotSerialNumber)

	utils.Logger.Infof("üì§ SENDING CANCEL ORDER: %s", string(reqData))

	token := e.mqttClient.Publish(topic, 0, false, reqData)
	token.Wait()

	if token.Error() != nil {
		return fmt.Errorf("MQTT publish failed: %v", token.Error())
	}

	return nil
}

// executeNextOrder Ï°∞Í±¥Ïóê ÎßûÎäî Îã§Ïùå Ïò§ÎçîÎ•º Ï∞æÏïÑ Ïã§Ìñâ
func (e *Executor) executeNextOrder(commandExecution *models.CommandExecution) error {
	e.db.Preload("Command.CommandDefinition").First(&commandExecution, commandExecution.ID)

	if commandExecution.CurrentOrderIndex == 0 {
		// ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÏôÑÎ£å
		return e.completeCommandExecution(commandExecution)
	}

	// Îã§Ïùå Ïò§Îçî Îß§Ìïë Ï°∞Ìöå
	var mapping models.CommandOrderMapping
	err := e.db.Where("command_definition_id = ? AND execution_order = ?",
		commandExecution.Command.CommandDefinitionID, commandExecution.CurrentOrderIndex).
		Preload("Template.OrderSteps", func(db *gorm.DB) *gorm.DB {
			return db.Order("step_order ASC")
		}).
		Preload("Template.OrderSteps.NodeTemplate").
		Preload("Template.OrderSteps.StepActionMappings.ActionTemplate.Parameters").
		Preload("Template.OrderSteps.Edges").
		First(&mapping).Error

	if err != nil {
		errMsg := fmt.Sprintf("no order mapping found for index %d: %v", commandExecution.CurrentOrderIndex, err)
		utils.Logger.Errorf("Workflow for CommandExecutionID %d will be terminated. Reason: %s", commandExecution.ID, errMsg)

		now := time.Now()
		repository.UpdateCommandExecutionStatus(e.db, commandExecution, models.CommandExecutionStatusFailed, &now)
		repository.UpdateCommandStatus(e.db, &commandExecution.Command, models.StatusFailure, errMsg)
		e.sendResponseToPLC(commandExecution.Command.CommandDefinition.CommandType, "F", errMsg)
		return fmt.Errorf(errMsg)
	}

	// ÏÉà Ïò§Îçî Ïã§Ìñâ ÏÉùÏÑ±
	orderExecution := &models.OrderExecution{
		CommandExecutionID: commandExecution.ID,
		TemplateID:         mapping.TemplateID,
		OrderID:            e.orderBuilder.GenerateOrderID(),
		ExecutionOrder:     mapping.ExecutionOrder,
		CurrentStep:        1,
		Status:             models.OrderExecutionStatusRunning,
		StartedAt:          time.Now(),
	}
	if err := e.db.Create(orderExecution).Error; err != nil {
		return fmt.Errorf("failed to create order execution: %v", err)
	}

	utils.Logger.Infof("Starting order execution: %s (Index: %d)", orderExecution.OrderID, orderExecution.ExecutionOrder)

	// Ï≤´ Î≤àÏß∏ Îã®Í≥Ñ Ïã§Ìñâ
	e.stepManager.ExecuteNextStep(orderExecution, &mapping.Template)
	return nil
}

// completeCommandExecution Î™ÖÎ†π Ïã§Ìñâ ÏôÑÎ£å Ï≤òÎ¶¨
func (e *Executor) completeCommandExecution(commandExecution *models.CommandExecution) error {
	var failedOrderCount int64
	e.db.Model(&models.OrderExecution{}).Where("command_execution_id = ? AND status = ?",
		commandExecution.ID, models.OrderExecutionStatusFailed).Count(&failedOrderCount)

	finalStatus := models.CommandExecutionStatusCompleted
	finalCommandStatus := models.StatusSuccess
	if failedOrderCount > 0 {
		finalStatus = models.CommandExecutionStatusFailed
		finalCommandStatus = models.StatusFailure
	}

	now := time.Now()
	repository.UpdateCommandExecutionStatus(e.db, commandExecution, finalStatus, &now)
	repository.UpdateCommandStatus(e.db, &commandExecution.Command, finalCommandStatus, "")
	e.sendResponseToPLC(commandExecution.Command.CommandDefinition.CommandType, finalCommandStatus, "")

	utils.Logger.Infof("Workflow completed for command execution ID: %d with status: %s", commandExecution.ID, finalStatus)
	return nil
}

// triggerNextOrder Îã§Ïùå Ïò§Îçî Ìä∏Î¶¨Í±∞ (ÏÑ±Í≥µ/Ïã§Ìå®Ïóê Îî∞Îùº)
func (e *Executor) TriggerNextOrder(completedOrder *models.OrderExecution, success bool) {
	var cmdExec models.CommandExecution
	e.db.Preload("Command.CommandDefinition").First(&cmdExec, completedOrder.CommandExecutionID)

	var currentMapping models.CommandOrderMapping
	e.db.Where("command_definition_id = ? AND execution_order = ?",
		cmdExec.Command.CommandDefinitionID, completedOrder.ExecutionOrder).First(&currentMapping)

	var nextOrderIndex int
	if success {
		nextOrderIndex = currentMapping.NextExecutionOrder
	} else {
		nextOrderIndex = currentMapping.FailureOrder
	}

	cmdExec.CurrentOrderIndex = nextOrderIndex
	e.db.Save(&cmdExec)
	e.executeNextOrder(&cmdExec)
}

// sendResponseToPLC PLCÏóê ÏùëÎãµ Ï†ÑÏÜ°
func (e *Executor) sendResponseToPLC(command, status, errMsg string) {
	if e.commandResultSender != nil {
		e.commandResultSender.SendResponseToPLC(command, status, errMsg)
	} else {
		// ÏßÅÏ†ë Ï†ÑÏÜ° (fallback)
		var finalStatus string
		if status == models.StatusSuccess {
			finalStatus = "S"
		} else if status == models.StatusFailure {
			finalStatus = "F"
		} else {
			finalStatus = status
		}

		response := fmt.Sprintf("%s:%s", command, finalStatus)
		if finalStatus == "F" && errMsg != "" {
			utils.Logger.Errorf("Command %s failed: %s", command, errMsg)
		}

		topic := e.config.PlcResponseTopic
		utils.Logger.Infof("Sending response to PLC: %s", response)
		token := e.mqttClient.Publish(topic, 0, false, response)
		if token.Wait() && token.Error() != nil {
			utils.Logger.Errorf("Failed to send response to PLC: %v", token.Error())
		}
	}
}

// sendOrder Ïò§Îçî Î©îÏãúÏßÄ Ï†ÑÏÜ°
func (e *Executor) sendOrder(orderPayload interface{}) error {
	topic := fmt.Sprintf("meili/v2/%s/%s/order", e.config.RobotManufacturer, e.config.RobotSerialNumber)

	msgData, err := json.Marshal(orderPayload)
	if err != nil {
		return fmt.Errorf("failed to marshal order message: %v", err)
	}

	utils.Logger.Infof("üì§ SENDING ORDER: %s", string(msgData))

	token := e.mqttClient.Publish(topic, 0, false, msgData)
	token.Wait()

	if token.Error() != nil {
		return fmt.Errorf("MQTT publish failed: %v", token.Error())
	}

	return nil
}

// GetRunningExecutions Ïã§Ìñâ Ï§ëÏù∏ Î™ÖÎ†π Ïã§ÌñâÎì§ Ï°∞Ìöå
func (e *Executor) GetRunningExecutions() ([]models.CommandExecution, error) {
	var executions []models.CommandExecution
	err := e.db.Where("status = ?", models.CommandExecutionStatusRunning).
		Preload("Command.CommandDefinition").Find(&executions).Error
	return executions, err
}

// GetExecutionByID ÌäπÏ†ï Ïã§Ìñâ Ï°∞Ìöå
func (e *Executor) GetExecutionByID(id uint) (*models.CommandExecution, error) {
	var execution models.CommandExecution
	err := e.db.Preload("Command.CommandDefinition").
		Preload("OrderExecutions.Steps").First(&execution, id).Error
	if err != nil {
		return nil, err
	}
	return &execution, nil
}

// MQTTMessageSender MQTT Î©îÏãúÏßÄ Ï†ÑÏÜ°Í∏∞ (MessageSender Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Íµ¨ÌòÑ)
type MQTTMessageSender struct {
	mqttClient mqtt.Client
	config     *config.Config
}

// SendOrderMessage Ïò§Îçî Î©îÏãúÏßÄ Ï†ÑÏÜ°
func (m *MQTTMessageSender) SendOrderMessage(orderMsg *models.OrderMessage) error {
	topic := fmt.Sprintf("meili/v2/%s/%s/order", m.config.RobotManufacturer, m.config.RobotSerialNumber)

	msgData, err := json.Marshal(orderMsg)
	if err != nil {
		return fmt.Errorf("failed to marshal order message: %v", err)
	}

	utils.Logger.Infof("üì§ SENDING ORDER MESSAGE: %s", string(msgData))

	token := m.mqttClient.Publish(topic, 0, false, msgData)
	token.Wait()

	if token.Error() != nil {
		return fmt.Errorf("MQTT publish failed: %v", token.Error())
	}

	return nil
}
